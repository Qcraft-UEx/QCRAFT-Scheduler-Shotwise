import requests
import time
import json 

url = 'http://localhost:8082/'
pathURL = 'url'
pathResult = 'result'
pathCircuit = 'code'

ids = []

i=0

urls = {
    "deutsch-jozsa": """from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import execute, Aer\nfrom qiskit import transpile\nfrom qiskit_ibm_provider import least_busy, IBMProvider\nimport numpy as np\n\nqreg_q = QuantumRegister(4, 'q')\ncreg_c = ClassicalRegister(4, 'c')\ncircuit = QuantumCircuit(qreg_q, creg_c)\ngate_machines_arn= {"local":"local", "ibm_brisbane":"ibm_brisbane", "ibm_osaka":"ibm_osaka", "ibm_kyoto":"ibm_kyoto", "simulator_stabilizer":"simulator_stabilizer", "simulator_mps":"simulator_mps", "simulator_extended_stabilizer":"simulator_extended_stabilizer", "simulator_statevector":"simulator_statevector"}\n\ncircuit.h(qreg_q[0])\ncircuit.h(qreg_q[1])\ncircuit.h(qreg_q[2])\ncircuit.x(qreg_q[3])\ncircuit.x(qreg_q[0])\ncircuit.x(qreg_q[2])\ncircuit.h(qreg_q[3])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2], qreg_q[3])\ncircuit.cx(qreg_q[0], qreg_q[3])\ncircuit.cx(qreg_q[1], qreg_q[3])\ncircuit.cx(qreg_q[2], qreg_q[3])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2], qreg_q[3])\ncircuit.x(qreg_q[0])\ncircuit.h(qreg_q[1])\ncircuit.x(qreg_q[2])\ncircuit.h(qreg_q[0])\ncircuit.h(qreg_q[2])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2], qreg_q[3])\ncircuit.measure(qreg_q[0], creg_c[0])\ncircuit.measure(qreg_q[1], creg_c[1])\ncircuit.measure(qreg_q[2], creg_c[2])\ncircuit.measure(qreg_q[3], creg_c[3])\n\nshots = 10000\nprovider = IBMProvider()\nbackend = Aer.get_backend('qasm_simulator')\n\nqc_basis = transpile(circuit, backend)\njob = execute(qc_basis, backend=backend, shots=shots)\njob_result = job.result()\nprint(job_result.get_counts(qc_basis))\n""",
    "bernstein-vazirani": """from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import execute, Aer\nfrom qiskit import transpile\nfrom qiskit_ibm_provider import least_busy, IBMProvider\nimport numpy as np\n\nqreg_q = QuantumRegister(4, 'q')\ncreg_c = ClassicalRegister(4, 'c')\ncircuit = QuantumCircuit(qreg_q, creg_c)\n\ngate_machines_arn= {"local":"local", "ibm_brisbane":"ibm_brisbane", "ibm_osaka":"ibm_osaka", "ibm_kyoto":"ibm_kyoto", "simulator_stabilizer":"simulator_stabilizer", "simulator_mps":"simulator_mps", "simulator_extended_stabilizer":"simulator_extended_stabilizer", "simulator_statevector":"simulator_statevector"}\n\ncircuit.x(qreg_q[3])\ncircuit.h(qreg_q[3])\ncircuit.h(qreg_q[0])\ncircuit.h(qreg_q[1])\ncircuit.h(qreg_q[2])\ncircuit.cx(qreg_q[0], qreg_q[3])\ncircuit.cx(qreg_q[1], qreg_q[3])\ncircuit.cx(qreg_q[2], qreg_q[3])\ncircuit.h(qreg_q[0])\ncircuit.h(qreg_q[1])\ncircuit.h(qreg_q[2])\ncircuit.barrier(qreg_q)\ncircuit.measure(qreg_q[0], creg_c[0])\ncircuit.measure(qreg_q[1], creg_c[1])\ncircuit.measure(qreg_q[2], creg_c[2])\ncircuit.measure(qreg_q[3], creg_c[3])\n\nshots = 10000\nprovider = IBMProvider()\nbackend = Aer.get_backend('qasm_simulator')\n\nqc_basis = transpile(circuit, backend)\njob = execute(qc_basis, backend=backend, shots=shots)\njob_result = job.result()\nprint(job_result.get_counts(qc_basis))""",
    "full_adder": """from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import execute, Aer\nfrom qiskit import transpile\nfrom qiskit_ibm_provider import least_busy, IBMProvider\nimport numpy as np\n\nqreg_q = QuantumRegister(4, 'q')\ncreg_c = ClassicalRegister(4, 'c')\ncircuit = QuantumCircuit(qreg_q, creg_c)\n\ncircuit.h(qreg_q[1])\ncircuit.h(qreg_q[2])\ncircuit.h(qreg_q[3])\ncircuit.h(qreg_q[0])\ncircuit.ccx(qreg_q[1], qreg_q[0], qreg_q[3])\ncircuit.cx(qreg_q[0], qreg_q[1])\ncircuit.ccx(qreg_q[1], qreg_q[2], qreg_q[3])\ncircuit.cx(qreg_q[1], qreg_q[2])\ncircuit.cx(qreg_q[0], qreg_q[1])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2], qreg_q[3])\ncircuit.measure(qreg_q[1], creg_c[1])\ncircuit.measure(qreg_q[0], creg_c[0])\ncircuit.measure(qreg_q[2], creg_c[2])\ncircuit.measure(qreg_q[3], creg_c[3])\n\nshots = 10000\nprovider = IBMProvider()\nbackend = Aer.get_backend('qasm_simulator')\n\nqc_basis = transpile(circuit, backend)\njob = execute(qc_basis, backend=backend, shots=shots)\njob_result = job.result()\nprint(job_result.get_counts(qc_basis))""",
    "grover": """from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import execute, Aer\nfrom qiskit import transpile\nfrom qiskit_ibm_provider import least_busy, IBMProvider\nimport numpy as np\n\nqreg_q = QuantumRegister(2, 'q')\ncreg_c = ClassicalRegister(2, 'c')\ncircuit = QuantumCircuit(qreg_q, creg_c)\n\ncircuit.h(qreg_q[0])\ncircuit.h(qreg_q[1])\ncircuit.x(qreg_q[1])\ncircuit.h(qreg_q[1])\ncircuit.cx(qreg_q[0], qreg_q[1])\ncircuit.h(qreg_q[1])\ncircuit.x(qreg_q[1])\ncircuit.h(qreg_q[1])\ncircuit.measure(qreg_q[0], creg_c[0])\ncircuit.measure(qreg_q[1], creg_c[1])\n\nshots = 10000\nprovider = IBMProvider()\nbackend = Aer.get_backend('qasm_simulator')\n\nqc_basis = transpile(circuit, backend)\njob = execute(qc_basis, backend=backend, shots=shots)\njob_result = job.result()\nprint(job_result.get_counts(qc_basis))""",
    "kickback": """from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import execute, Aer\nfrom qiskit import transpile\nfrom qiskit_ibm_provider import least_busy, IBMProvider\nimport numpy as np\n\nqreg_q = QuantumRegister(2, 'q')\ncreg_c = ClassicalRegister(2, 'c')\ncircuit = QuantumCircuit(qreg_q, creg_c)\n\ncircuit.x(qreg_q[1])\ncircuit.h(qreg_q[0])\ncircuit.h(qreg_q[1])\ncircuit.cx(qreg_q[0], qreg_q[1])\ncircuit.h(qreg_q[0])\ncircuit.h(qreg_q[1])\ncircuit.measure(qreg_q[1], creg_c[1])\ncircuit.measure(qreg_q[0], creg_c[0])\n\nshots = 10000\nprovider = IBMProvider()\nbackend = Aer.get_backend('qasm_simulator')\n\nqc_basis = transpile(circuit, backend)\njob = execute(qc_basis, backend=backend, shots=shots)\njob_result = job.result()\nprint(job_result.get_counts(qc_basis))""",
    "phase_estimation": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import execute, Aer\nfrom qiskit import transpile\nfrom qiskit_ibm_provider import least_busy, IBMProvider\nimport numpy as np\n\nqreg_q = QuantumRegister(4, 'q')\ncreg_c = ClassicalRegister(4, 'c')\ncircuit = QuantumCircuit(qreg_q, creg_c)\n\ncircuit.h(qreg_q[0])\ncircuit.h(qreg_q[1])\ncircuit.h(qreg_q[2])\ncircuit.x(qreg_q[3])\ncircuit.cp(np.pi / 4, qreg_q[0], qreg_q[3])\ncircuit.cp(np.pi / 4, qreg_q[1], qreg_q[3])\ncircuit.cp(np.pi / 4, qreg_q[1], qreg_q[3])\ncircuit.cp(np.pi / 4, qreg_q[2], qreg_q[3])\ncircuit.cp(np.pi / 4, qreg_q[2], qreg_q[3])\ncircuit.cp(np.pi / 4, qreg_q[2], qreg_q[3])\ncircuit.cp(np.pi / 4, qreg_q[2], qreg_q[3])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2], qreg_q[3])\ncircuit.swap(qreg_q[0], qreg_q[2])\ncircuit.h(qreg_q[0])\ncircuit.cp(-np.pi / 2, qreg_q[0], qreg_q[1])\ncircuit.h(qreg_q[1])\ncircuit.cp(-np.pi / 4, qreg_q[0], qreg_q[2])\ncircuit.cp(-np.pi / 2, qreg_q[1], qreg_q[2])\ncircuit.h(qreg_q[2])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2], qreg_q[3])\ncircuit.measure(qreg_q[0], creg_c[0])\ncircuit.measure(qreg_q[2], creg_c[2])\ncircuit.measure(qreg_q[1], creg_c[1])\n\nshots = 10000\nprovider = IBMProvider()\nbackend = Aer.get_backend('qasm_simulator')\n\nqc_basis = transpile(circuit, backend)\njob = execute(qc_basis, backend=backend, shots=shots)\njob_result = job.result()\nprint(job_result.get_counts(qc_basis))""",
    "qaoa": """from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, Aer, execute\nfrom numpy import pi\n\nqreg_q = QuantumRegister(2, 'q')\ncreg_c = ClassicalRegister(2, 'c')\ncircuit = QuantumCircuit(qreg_q, creg_c)\n\n# Parameters\n# First layer of mixing and cost Hamiltonian\ncircuit.rx(0.5, qreg_q[0])\ncircuit.rx(0.5, qreg_q[1])\ncircuit.cx(qreg_q[0], qreg_q[1])\ncircuit.rx(0.5, qreg_q[1])\n# Second layer of mixing and cost Hamiltonian\ncircuit.rx(0.5, qreg_q[0])\ncircuit.rx(0.5, qreg_q[1])\ncircuit.cx(qreg_q[0], qreg_q[1])\ncircuit.rx(0.5, qreg_q[0])\n# Measurement\ncircuit.measure(qreg_q[0], creg_c[0])\ncircuit.measure(qreg_q[1], creg_c[1])\n\nbackend = Aer.get_backend("qasm_simulator")\nx=int(1024)\njob = execute(circuit, backend, shots=x)\nresult = job.result()\ncounts = result.get_counts()\nreturn counts""",
    "qft": """from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import execute, Aer\nfrom qiskit import transpile\nfrom qiskit_ibm_provider import least_busy, IBMProvider\nimport numpy as np\n\nqreg_q = QuantumRegister(3, 'q')\ncreg_c = ClassicalRegister(3, 'c')\ncircuit = QuantumCircuit(qreg_q, creg_c)\n\ncircuit.h(qreg_q[2])\ncircuit.h(qreg_q[1])\ncircuit.h(qreg_q[0])\ncircuit.h(qreg_q[2])\ncircuit.cp(np.pi / 2, qreg_q[2], qreg_q[1])\ncircuit.cp(np.pi / 4, qreg_q[2], qreg_q[0])\ncircuit.h(qreg_q[1])\ncircuit.cp(np.pi / 2, qreg_q[1], qreg_q[0])\ncircuit.h(qreg_q[0])\ncircuit.swap(qreg_q[0], qreg_q[2])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2])\ncircuit.measure(qreg_q[1], creg_c[1])\ncircuit.measure(qreg_q[0], creg_c[0])\ncircuit.measure(qreg_q[2], creg_c[1])\n\nshots = 10000\nprovider = IBMProvider()\nbackend = Aer.get_backend('qasm_simulator')\n\nqc_basis = transpile(circuit, backend)\njob = execute(qc_basis, backend=backend, shots=shots)\njob_result = job.result()\nprint(job_result.get_counts(qc_basis))""",
    "qwalk": """from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import execute, Aer\nfrom qiskit import transpile\nfrom qiskit_ibm_provider import least_busy, IBMProvider\nimport numpy as np\n\nqreg_q = QuantumRegister(3, 'q')\ncreg_c = ClassicalRegister(3, 'c')\ncircuit = QuantumCircuit(qreg_q, creg_c)\ncircuit.h(qreg_q[2])\ncircuit.cx(qreg_q[2], qreg_q[1])\ncircuit.ccx(qreg_q[2], qreg_q[1], qreg_q[0])\ncircuit.x(qreg_q[2])\ncircuit.cx(qreg_q[2], qreg_q[1])\ncircuit.x(qreg_q[1])\ncircuit.ccx(qreg_q[2], qreg_q[1], qreg_q[0])\ncircuit.x(qreg_q[1])\ncircuit.x(qreg_q[2])\ncircuit.cx(qreg_q[2], qreg_q[1])\ncircuit.ccx(qreg_q[2], qreg_q[1], qreg_q[0])\ncircuit.x(qreg_q[2])\ncircuit.cx(qreg_q[2], qreg_q[1])\ncircuit.x(qreg_q[1])\ncircuit.ccx(qreg_q[2], qreg_q[1], qreg_q[0])\ncircuit.x(qreg_q[1])\ncircuit.x(qreg_q[2])\ncircuit.measure(qreg_q[0], creg_c[0])\ncircuit.measure(qreg_q[1], creg_c[1])\ncircuit.measure(qreg_q[2], creg_c[2])\n\nshots = 10000\nprovider = IBMProvider()\nbackend = provider.get_backend('ibm_brisbane')\n\nqc_basis = transpile(circuit, backend)\njob = execute(qc_basis, backend=backend, shots=shots)\njob_result = job.result()\nprint(job_result.get_counts(qc_basis))""",
    "shor": """from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import execute, Aer\nfrom qiskit import transpile\nfrom qiskit_ibm_provider import least_busy, IBMProvider\nimport numpy as np\n\nqreg_q = QuantumRegister(4, 'q')\ncreg_c = ClassicalRegister(4, 'c')\ncircuit = QuantumCircuit(qreg_q, creg_c)\ncircuit.reset(qreg_q[0])\ncircuit.reset(qreg_q[1])\ncircuit.reset(qreg_q[2])\ncircuit.reset(qreg_q[3])\ncircuit.x(qreg_q[0])\ncircuit.x(qreg_q[0])\ncircuit.x(qreg_q[1])\ncircuit.x(qreg_q[2])\ncircuit.x(qreg_q[3])\ncircuit.cx(qreg_q[1], qreg_q[2])\ncircuit.cx(qreg_q[2], qreg_q[1])\ncircuit.cx(qreg_q[1], qreg_q[2])\ncircuit.cx(qreg_q[2], qreg_q[3])\ncircuit.cx(qreg_q[3], qreg_q[2])\ncircuit.cx(qreg_q[2], qreg_q[3])\ncircuit.cx(qreg_q[0], qreg_q[3])\ncircuit.cx(qreg_q[3], qreg_q[0])\ncircuit.cx(qreg_q[0], qreg_q[3])\ncircuit.measure(qreg_q[0], creg_c[0])\ncircuit.measure(qreg_q[1], creg_c[1])\ncircuit.measure(qreg_q[2], creg_c[2])\ncircuit.measure(qreg_q[3], creg_c[3])\n\nshots = 10000\nprovider = IBMProvider()\nbackend = provider.get_backend('ibm_brisbane')\n\nqc_basis = transpile(circuit, backend)\njob = execute(qc_basis, backend=backend, shots=shots)\njob_result = job.result()\nprint(job_result.get_counts(qc_basis))""",
    "simon": """from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import execute, Aer\nfrom qiskit import transpile\nfrom qiskit_ibm_provider import least_busy, IBMProvider\nimport numpy as np\n\nqreg_q = QuantumRegister(6, 'q')\ncreg_c = ClassicalRegister(6, 'c')\ncircuit = QuantumCircuit(qreg_q, creg_c)\ngate_machines_arn= {"local":"local", "ibm_brisbane":"ibm_brisbane", "ibm_osaka":"ibm_osaka", "ibm_kyoto":"ibm_kyoto", "simulator_stabilizer":"simulator_stabilizer", "simulator_mps":"simulator_mps", "simulator_extended_stabilizer":"simulator_extended_stabilizer", "simulator_statevector":"simulator_statevector"}\n\ncircuit.h(qreg_q[0])\ncircuit.h(qreg_q[1])\ncircuit.h(qreg_q[2])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2], qreg_q[3], qreg_q[4], qreg_q[5])\ncircuit.cx(qreg_q[0], qreg_q[3])\ncircuit.cx(qreg_q[1], qreg_q[4])\ncircuit.cx(qreg_q[2], qreg_q[5])\ncircuit.cx(qreg_q[1], qreg_q[4])\ncircuit.cx(qreg_q[1], qreg_q[5])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2], qreg_q[3], qreg_q[4], qreg_q[5])\ncircuit.h(qreg_q[0])\ncircuit.h(qreg_q[1])\ncircuit.h(qreg_q[2])\ncircuit.measure(qreg_q[0], creg_c[0])\ncircuit.measure(qreg_q[1], creg_c[1])\ncircuit.measure(qreg_q[2], creg_c[2])\ncircuit.measure(qreg_q[3], creg_c[3])\ncircuit.measure(qreg_q[4], creg_c[4])\ncircuit.measure(qreg_q[5], creg_c[5])\n\nshots = 10000\nprovider = IBMProvider()\nbackend = Aer.get_backend('qasm_simulator')\n\nqc_basis = transpile(circuit, backend)\njob = execute(qc_basis, backend=backend, shots=shots)\njob_result = job.result()\nprint(job_result.get_counts(qc_basis))""",
    "teleportation": """from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import execute, Aer\nfrom qiskit import transpile\nfrom qiskit_ibm_provider import least_busy, IBMProvider\nimport numpy as np\n\nqreg_q = QuantumRegister(3, 'q')\ncreg_c = ClassicalRegister(3, 'c')\ncircuit = QuantumCircuit(qreg_q, creg_c)\n\ncircuit.h(qreg_q[0])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2])\ncircuit.h(qreg_q[1])\ncircuit.cx(qreg_q[1], qreg_q[2])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2])\ncircuit.h(qreg_q[0])\ncircuit.p(np.pi / 4, qreg_q[0])\ncircuit.h(qreg_q[0])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2])\ncircuit.cx(qreg_q[0], qreg_q[1])\ncircuit.h(qreg_q[0])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2])\ncircuit.measure(qreg_q[0], creg_c[0])\ncircuit.measure(qreg_q[1], creg_c[1])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2])\ncircuit.z(qreg_q[2]).c_if(creg_c[0], 1)\ncircuit.x(qreg_q[2]).c_if(creg_c[1], 1)\n\nshots = 10000\nprovider = IBMProvider()\nbackend = Aer.get_backend('qasm_simulator')\n\nqc_basis = transpile(circuit, backend)\njob = execute(qc_basis, backend=backend, shots=shots)\njob_result = job.result()\nprint(job_result.get_counts(qc_basis))""",
    "tsp": """from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import execute, Aer\nfrom qiskit import transpile\nfrom qiskit_ibm_provider import least_busy, IBMProvider\nimport numpy as np\n\nqreg_q = QuantumRegister(5, 'q')\ncreg_c = ClassicalRegister(5, 'c')\ncircuit = QuantumCircuit(qreg_q, creg_c)\n\ncircuit.h(qreg_q[0])\ncircuit.x(qreg_q[1])\ncircuit.x(qreg_q[2])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2])\ncircuit.cx(qreg_q[1], qreg_q[0])\ncircuit.cx(qreg_q[2], qreg_q[0])\ncircuit.barrier(qreg_q[0], qreg_q[1], qreg_q[2])\ncircuit.h(qreg_q[0])\ncircuit.measure(qreg_q[0], creg_c[0])\ncircuit.measure(qreg_q[1], creg_c[1])\ncircuit.measure(qreg_q[2], creg_c[2])\n\nshots = 10000\nprovider = IBMProvider()\nbackend = Aer.get_backend('qasm_simulator')\n\nqc_basis = transpile(circuit, backend)\njob = execute(qc_basis, backend=backend, shots=shots)\njob_result = job.result()\nprint(job_result.get_counts(qc_basis))"""

}

for elem in urls:
    data = {"code":urls[elem] ,"shots" : 10000, "policy":"time", "machine":"local"}
    print(elem+":"+requests.post(url+pathCircuit, json = data).text)


